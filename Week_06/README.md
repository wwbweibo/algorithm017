# 学习笔记

DP: 分治+最优子结构

- 动态规划和递归或者分治没有根本区别（关键看有没有最优子结构）
  - 共性：找到重复子问题
  - 差异性：最有子结构，中途可以淘汰次优解

自顶向下
自底向上

**1. 最优子结构**
**2. 存储中间状态dp[i]**
**3. dp方程**

## 例题

### 1. 斐波拉契数列

$f(n) = f(n-1) + f(n-2)$
$f(0) = 0$
$f(1) = 1$

- 递归解法时间复杂度为$O(2^n)$
- 记忆化搜索，使用缓存
- DP，使用一个一维数组用于保存各步骤的中间结果

### 2. 路径计数

递推公式$opt[i][j] = opt[i][j+1] + opt[i+1][j]$

使用二维数组包保存中间结果

### 3. 最长公共子序列

对于字符串，转化为二位数组的形式，行和列分别为两个字符串，*从后往前看*

$$
LCS(s1, s2) =
    \begin{cases}
     max(LCS(s1- 1, s2), LCS(s1, s2-1)), & \text{if } s1_{-1} \neq s2_{-1} \\
    LCS(s1 - 1, s2 - 1) + 1, & \text{if } s1_{-1} = s2_{-1}
    \end{cases}
$$

### 4. 三角形最下路径和

a. 子问题：`problem(i, j) = min(sub(i + 1, j), sub(i + 1, j + 1)) + a[i,j]`
b. 定义数组状态：`f[i,j]`
c. dp方程：`f[i,j] = min(f[i +1,j], f[i + 1, j + 1]) + a[i,j]`

### 5. 最大子序列和

a. 子问题：max_sum(i) = max(max_sum(i-1),0) + a[i]
b. 定义数组状态：f[i]
c. DP方程：`f[i] = max(f[i-1], 0) + a[i]`

### 6. 零钱兑换

a. 子问题：f(n) = min(f(n -k)) + 1 (k in coins)
b. 定义数组状态：dp[i]
c. DP方程：dp[n] = min(dp[n-k]) + 1 (k in coins)

### 7. 打家劫舍

dp[i][0,1] 0-i能偷到的max value，0 - 不偷， 1 - 偷

a[i][0] = max(a[i-1][0], a[a-i][1])
a[i][1] = a[i-1][0] + nums[i]

dp[i] 0-i能偷到的max value
dp[i] = max(a[i-1], nums[i] + a[i-2])