学习笔记

## 数组

数组是一种线性数据结构，数组在创建的时候会在内存中开辟一段连续的内存空间。数组支持随机访问。通常在高级语言中的ArrayList支持动态扩容，即在当前数组容量满了之后另外开辟一段空间，并将当前的空间中的内容拷贝到新数组中

各类操作的时间复杂度

- 访问元素： $O(1)$
- 添加元素： $O(n)$，添加元素时，会将插入下标之后的元素向后移动一位
- 删除元素： $O(n)$，删除元素时，会将删除下标之后的元素向前移动一位

## 链表

链表同样是一种线性数据结构，与数组不同的是，数组会在内存中开辟一段连续的内存空间，而链表并不会，链表的数据保存的一个一个的节点当中，节点和节点之间通过指针相连

### 单向链表

节点中只有一个指针`next`，指向当前当前节点的下一个节点，只能支持从头到尾的遍历

### 双向链表

除了指向下一个节点next指针之外，还有一个prev指针指向上一个节点，可以从两个方向进行遍历

### 循环链表

循环链表的尾节点的next指针指向头节点

```go
// 单向
type LinkedListNode struct {
    value int
    next *LinkedListNode
}
// 双向
type LinkedListNode struct {
    value int
    next *LinkedListNode
    prev *LinkedListNode
}
```

各类操作的时间复杂度

- 访问元素： $O(n)$，需要遍历节点进行访问
- 添加元素： $O(1)$
- 删除元素： $O(n)$

## 跳表

1. 链表中的元素有序
2. 在链表的基础上通过增加多级索引来提升查询效率

各类操作的时间复杂度

- 访问元素： $O(logn)$
- 添加元素： $O(logn)$
- 删除元素： $O(logn)$

空间复杂度$O(n)$

## 栈

栈是一种特殊的线性数据结构，只能在尾部进行数据的添加和删除（后入先出）

各类操作的时间复杂度

- 访问元素： $O(n)$
- 添加元素： $O(1)$
- 删除元素： $O(1)$

## 队列

栈是一种特殊的线性数据结构，只能在尾部进行数据的添加，在头部进行删除（先入先出）

各类操作的时间复杂度

- 访问元素： $O(n)$
- 添加元素： $O(1)$
- 删除元素： $O(1)$

### 双端队列

双端队列可以看作是栈和队列的结合，同时支持在头部和尾部进行数据的添加和删除

各类操作的时间复杂度

- 访问元素： $O(n)$
- 添加元素： $O(1)$
- 删除元素： $O(1)$

### 优先队列

优先队列的的取出会按照元素的优先级来进行

各类操作的时间复杂度

- 访问元素： $O(n)$
- 添加元素： $O(1)$
- 删除元素： $O(logn)$

#### Java 优先队列源码

优先队列，底层使用的一个基于数据实现的堆，通过调用`siftUp`和`siftDown`两个方法来进行优先级的排序
方法中会判断是否有自定义的比较器，如果存在自定义的比较器，使用自定义的，否则，使用默认的  

``` java
private void siftUpComparable(int k, E x) {
    Comparable<? super E> key = (Comparable<? super E>) x;
    while (k > 0) {
        // 获取父节点位置
        int parent = (k - 1) >>> 1;
        // 获取父节点元素
        Object e = queue[parent];
        // 如果插入的元素大于父节点（构成小顶堆），结束循环
        if (key.compareTo((E) e) >= 0)
            break;
        // 如果插入的元素小于父节点元素，将父节点元素调整下来
        queue[k] = e;
        // 记录父节点位置，继续向上判断调整
        k = parent;
    }
    // 调整后将插入的元素放在对应的位置上
    queue[k] = key;
}
```